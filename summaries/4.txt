# Data Abstractions
  - A module is in charge of abstracting some data, e.g List, String
  - The module's function usually expect an instance of the data abstraction as the first argument, e.g
    - The first argument to any String function is a string type -- "my_string"
    - The first argument to any List function is a list type -- [1, 4]
  - Modifier functions return a modified version of the abstraction, e.g
    - String.upcase/1 returns a string
    - List.insert_at/3 returns a list
  - Query functions return some other type of data, e.g
    - String
    - List.contains?(my_list) returns boolean

## Abstracting with struct
 - Each module can define only a struct.
 - Use struct over map since struct can be used to create and pattern-match instances. Pattern matching struct gives us the assurance that we are only working with a certain struct.
 - Some things that can be done with maps don't work with struct, even though they look similar. For example, the Enum function can't be used on struct. For example, this will throw an error:
 iex> Enum.list(my_struct)
 - A struct pattern can't match a plain map but a plain map pattern match a struct. This is is because Struct contains a :__struct__ key that is not available in maps. For example:
 iex> my_struct = %{a: 1, b: 2} will throw an error
 iex> %{a: a, b: b} = my_struct will pass
