# Working with processes
- In BEAM, a process has to be created to run something concurrently.

## Creating processes
- Use spawn/1 to create a process
- The order of process isn't guaranteed

## Message passing
- Use send/2 to send a message, e.g send(pid, {:my, :message})
- Receiver consumes messages in the order received
- Message can be removed from the queue only if it's consumed

- Use receive/0 to listen to messages
- receive/0 will always wait for new messages to come in
- after/0 is used to timeout a receive block
+ Example:
```
receive do
  message -> IO.inspect(message)
after
  5000 -> IO.puts("This receive block will timeout if no message is received after 5 seconds")
end
```

- receive/0 is a blocking code. This means every code after the receive block won't run because receive/0 will continue to listen to messages. 
- If the after/0 clause is specified and no message is matched in the given amount of time, run the code from the after/0 block.

## Server processes are sequential
- Server process is internally sequential, the query run one after the other.
  This might be a problem if we want the server process to run sequentially.
- Assuming the queries can be run independently, then a pool of server processes
  can be created, and then for each query somehow choose one of the processes
  from the pool and have that process run the query. If the pool is large enough
  and you divide the work uniformly across each worker in the pool,
  youâ€™ll parallelize the total work as much as possible.
- E.g
  ```
  # create 100 pools
  pools = Enum.map(1..100, fn _ -> DatabaseServer.start() end)

  # select a random process
  Enum.each(
    1...5,
    fn query_def ->
      server_pid = Enum.at(pools, :rand.uniform(100) - 1)
      DatabaseServer.run_async(server_pid, query_def)
    end
  )

  # collect response
  Enum.map(1..5, fn _ -> DatabaseServer.get_result() end)
  # ["5 result", "3 result", "1 result", "4 result", "2 result"]
  ```

## Registered processes
- Use Process.register/2 to give a process a local name
```
# :some_name must be an atom
Process.register(self(), :some_name)
```
 - Rules for registering processes:
  - The name can only be an atom
  - A single process can have only one name
  - Two processes can't have the same name
 An error will be raised if any of the above rules is violated.
