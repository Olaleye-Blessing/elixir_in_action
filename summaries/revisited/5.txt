# Working with processes
- In BEAM, a process has to be created to run something concurrently.

## Creating processes
- Use spawn/1 to create a process
- The order of process isn't guaranteed

## Message passing
- Use send/2 to send a message, e.g send(pid, {:my, :message})
- Receiver consumes messages in the order received
- Message can be removed from the queue only if it's consumed

- Use receive/0 to listen to messages
- receive/0 will always wait for new messages to come in
- after/0 is used to timeout a receive block
+ Example:
```
receive do
  message -> IO.inspect(message)
after
  5000 -> IO.puts("This receive block will timeout if no message is received after 5 seconds")
end
```

- receive/0 is a blocking code. This means every code after the receive block won't run because receive/0 will continue to listen to messages. 
- If the after/0 clause is specified and no message is matched in the given amount of time, run the code from the after/0 block.

## Server processes are sequential
- Server process is internally sequential, the query run one after the other.
  This might be a problem if we want the server process to run sequentially.
- Assuming the queries can be run independently, then a pool of server processes
  can be created, and then for each query somehow choose one of the processes
  from the pool and have that process run the query. If the pool is large enough
  and you divide the work uniformly across each worker in the pool,
  youâ€™ll parallelize the total work as much as possible.
- E.g
  ```
  # create 100 pools
  pools = Enum.map(1..100, fn _ -> DatabaseServer.start() end)

  # select a random process
  Enum.each(
    1...5,
    fn query_def ->
      server_pid = Enum.at(pools, :rand.uniform(100) - 1)
      DatabaseServer.run_async(server_pid, query_def)
    end
  )

  # collect response
  Enum.map(1..5, fn _ -> DatabaseServer.get_result() end)
  # ["5 result", "3 result", "1 result", "4 result", "2 result"]
  ```

## Registered processes
- Use Process.register/2 to give a process a local name
```
# :some_name must be an atom
Process.register(self(), :some_name)
```
 - Rules for registering processes:
  - The name can only be an atom
  - A single process can have only one name
  - Two processes can't have the same name
 An error will be raised if any of the above rules is violated.

## Runtime considerations

### A process is sequential
- A single process is always sequential, i.e it process one message at a time.
  If many processes send messages to a single process, that single process can
  significantly affect overall performace.
- One of the ways to handle this is to make sure the single process handle messages
  as fast as they can.
- Another way is to split the single process into multiple process(This should be
  the last resort tho).

### Unlimited process mailboxes
- Too many messages in the mailbox may cause a slow response. Remeber the server has
  to go through the messages one by one while responding to messages. Problems happen
  when the messages arrive faster than the process can handle them. The single slow
  process may cause an entire system to crash by consuming all the available memory.
- Too many messages can be in the mailbox when the process doesn't handle unknow messages.
  It's recommemded to have a match-all receive clause that deals with these kinds of messages
```
receive
  {:message, msg} -> do_something(msg)
  other -> log_unknown_message(other) 
end
```

### Shared-nothing concurrency
  - Sending a message to another process results in a deep copy of the message contents
  ```
  send(pid, message)
  ```
  - Deep-copying is an in-memory operation, so it should be reasonably fast and
    sending a big message shouldn't present a problem.
  - Problem might arise when many processes frequently sends big messages
  - Sharing nothing concurrency helps
    - to simplify the code for each process. A complicated synchronization
      mechanism won't be needed since processes don't share memory.
    - in overall stability. One process can't compromise another process.

### Scheduler inner workings
(Read this again)
